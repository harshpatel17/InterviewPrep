Selection Sort 
  Repeatedly find the minimum element and put it in front of array 
  Algorithm maintains 2 subarrays within the array 
    Sorted subarray 
    Unsorted subarray 

  for i in range(len(A)): 

      # Find the minimum element in remaining  
      # unsorted array 
      min_idx = i 
      for j in range(i+1, len(A)): 
          if A[min_idx] > A[j]: 
              min_idx = j 

      # Swap the found minimum element with  
      # the first element         
      A[i], A[min_idx] = A[min_idx], A[i] 

Bubble Sort 
  Repeatedly swaps adjacent elements to conform to sorting order 
  
  # Traverse through all array elements 
    for i in range(n): 
  
        # Last i elements are already in place 
        for j in range(0, n-i-1): 
  
            # traverse the array from 0 to n-i-1 
            # Swap if the element found is greater 
            # than the next element 
            if arr[j] > arr[j+1] : 
                arr[j], arr[j+1] = arr[j+1], arr[j] 

Insertion Sort 
  Start with a key, and traverse the left side, if a[key] < and value then swap 
  Similiar to sorting cards 
  
  def insertionSort(arr): 
  
    # Traverse through 1 to len(arr) 
    for i in range(1, len(arr)): 
  
        key = arr[i] 
  
        # Move elements of arr[0..i-1], that are 
        # greater than key, to one position ahead 
        # of their current position 
        j = i-1
        while j >= 0 and key < arr[j] : 
                arr[j + 1] = arr[j] 
                j -= 1
        arr[j + 1] = key 
  
 
